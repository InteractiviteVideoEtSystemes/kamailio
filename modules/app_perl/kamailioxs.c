/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of kamailioxs.xs. Do not edit this file, edit kamailioxs.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "kamailioxs.xs"
/*
 * $Id$
 *
 * Perl module for Kamailio
 *
 * Copyright (C) 2006 Collax GmbH
 *                    (Bastian Friedrich <bastian.friedrich@collax.com>)
 *
 * This file is part of kamailio, a free SIP server.
 *
 * Kamailio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version
 *
 * Kamailio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#include <EXTERN.h>
#include <perl.h>
#include <XSUB.h>
#include <unistd.h>
#undef load_module

/* perl.h defines union semun */
#ifdef USE_SYSV_SEM
# undef _SEM_SEMUN_UNDEFINED
#endif

#include "../../sr_module.h"
#include "../../parser/msg_parser.h"
#include "../../parser/parse_uri.h"
#include "../../usr_avp.h"
#include "../../action.h"
#include "../../flags.h"
#include "../../pvar.h"
#include "../../dset.h"
#include "../../mem/mem.h"
#include "../../route_struct.h"
#include "../../qvalue.h"
#include "../../dprint.h"

extern int unsafemodfnc;

enum xs_uri_members {
	XS_URI_USER = 0,
	XS_URI_PASSWD,
	XS_URI_HOST,
	XS_URI_PORT,
	XS_URI_PARAMS,
	XS_URI_HEADERS,
	XS_URI_TRANSPORT,
	XS_URI_TTL,
	XS_URI_USER_PARAM,
	XS_URI_MADDR,
	XS_URI_METHOD,
	XS_URI_LR,
	XS_URI_R2,
	XS_URI_TRANSPORT_VAL,
	XS_URI_TTL_VAL,
	XS_URI_USER_PARAM_VAL,
	XS_URI_MADDR_VAL,
	XS_URI_METHOD_VAL,
	XS_URI_LR_VAL,
	XS_URI_R2_VAL
	
	/* These members are no strings:
		unsigned short port_no;
	unsigned short proto; / * from transport * /
	uri_type type; / * uri scheme */
};

/*
 * Return the sip_msg struct referred to by perl reference sv
 */
struct sip_msg * sv2msg(SV *sv) {
	struct sip_msg* m;
	if (SvROK(sv)) {
		sv = SvRV(sv);
		if (SvIOK(sv)) {
			m = INT2PTR(struct sip_msg*, SvIV(sv));
			return m;
		}
	}
	return NULL; /* In case of error above... */
}

struct sip_uri * sv2uri(SV *sv) {
	struct sip_uri* u;
	if (SvROK(sv)) {
		sv = SvRV(sv);
		if (SvIOK(sv)) {
			u = INT2PTR(struct sip_uri*, SvIV(sv));
			return u;
		}
	}
	return NULL; /* In case of error above... */
}

struct action * sv2action(SV *sv) {
	struct action* a;
	if (SvROK(sv)) {
		sv = SvRV(sv);
		if (SvIOK(sv)) {
			a = INT2PTR(struct action*, SvIV(sv));
			return a;
		}
	}
	return NULL; /* In case of error above... */
}

/*
 * We have a private function for two reasons:
 * a) Return SIP_INVALID even if type was sth different
 * b) easy access
 */

inline static int getType(struct sip_msg *msg) {
	int t = SIP_INVALID;

	if (!msg) return SIP_INVALID;

	switch ((msg->first_line).type) {
		case SIP_REQUEST:	t = SIP_REQUEST; break;
		case SIP_REPLY:		t = SIP_REPLY; break;
	}
	return t;
}
		

SV *getStringFromURI(SV *self, enum xs_uri_members what) {
	struct sip_uri *myuri = sv2uri(self);
	str *ret = NULL;

	if (!myuri) {
		LM_ERR("Invalid URI reference\n");
		ret = NULL;
	} else {
		
		switch (what) {
			case XS_URI_USER:	ret = &(myuri->user);
						break;
			case XS_URI_HOST:	ret = &(myuri->host);
						break;
			case XS_URI_PASSWD:	ret = &(myuri->passwd);
						break;
			case XS_URI_PORT:	ret = &(myuri->port);
						break;
			case XS_URI_PARAMS:	ret = &(myuri->params);
						break;
			case XS_URI_HEADERS:	ret = &(myuri->headers);
						break;
			case XS_URI_TRANSPORT:	ret = &(myuri->transport);
						break;
			case XS_URI_TTL:		ret = &(myuri->ttl);
						break;
			case XS_URI_USER_PARAM:	ret = &(myuri->user_param);
						break;
			case XS_URI_MADDR:	ret = &(myuri->maddr);
						break;
			case XS_URI_METHOD:	ret = &(myuri->method);
						break;
			case XS_URI_LR:		ret = &(myuri->lr);
						break;
			case XS_URI_R2:		ret = &(myuri->r2);
						break;
			case XS_URI_TRANSPORT_VAL:	ret = &(myuri->transport_val);
						break;
			case XS_URI_TTL_VAL:	ret = &(myuri->ttl_val);
						break;
			case XS_URI_USER_PARAM_VAL:	ret = &(myuri->user_param_val);
						break;
			case XS_URI_MADDR_VAL:	ret = &(myuri->maddr_val);
						break;
			case XS_URI_METHOD_VAL:	ret = &(myuri->method_val);
						break;
			case XS_URI_LR_VAL:	ret = &(myuri->lr_val);
						break;
			case XS_URI_R2_VAL:	ret = &(myuri->r2_val);
						break;

			default:	LM_INFO("Unknown URI element"
						" requested: %d\n", what);
					break;
		}
	}

	if ((ret) && (ret->len)) {
		return sv_2mortal(newSVpv(ret->s, ret->len));
	} else {
		return &PL_sv_undef;
	}
}



/*
 * Calls an exported function. Parameters are copied and fixup'd.
 *
 * Return codes:
 *   -1 - Function not available (or other error).
 *    1 - Function was called. Its return value is returned via the retval
 *        parameter.
 */

int moduleFunc(struct sip_msg *m, char *func,
	       char *param1, char *param2,
	       int *retval) {

	sr31_cmd_export_t* exp_func_struct;
	struct action *act;
	unsigned mod_ver;
	char *argv[2];
	int argc = 0;
	struct run_act_ctx ra_ctx;

	if (!func) {
		LM_ERR("moduleFunc called with null function name. Error.");
		return -1;
	}

	if ((!param1) && param2) {
		LM_ERR("moduleFunc called with parameter 1 UNSET and"
			   " parameter 2 SET. Error.");
		return -1;
	}


	if (param1) {
		argv[0] = (char *)pkg_malloc(strlen(param1)+1);
		strcpy(argv[0], param1);
		argc++;
	} else {
		argv[0] = NULL;
	}

	if (param2) {
		argv[1] = (char *)pkg_malloc(strlen(param2)+1);
		strcpy(argv[1], param2);
		argc++;
	} else {
		argv[1] = NULL;
	}

	exp_func_struct = find_export_record(func, argc, 0, &mod_ver);
	if (!exp_func_struct || mod_ver < 1) {
		LM_ERR("function '%s' called, but not available.", func);
		*retval = -1;
		if (argv[0]) pkg_free(argv[0]);
		if (argv[1]) pkg_free(argv[1]);
		return -1;
	}

	act = mk_action(MODULE2_T, 4 /* number of (type, value) pairs */,
					MODEXP_ST, exp_func_struct, /* function */
					NUMBER_ST, 2,  /* parameter number */
					STRING_ST, argv[0], /* param. 1 */
					STRING_ST, argv[1]  /* param. 2 */
			);


	if (!act) {
		LM_ERR("action structure could not be created. Error.");
		if (argv[0]) pkg_free(argv[0]);
		if (argv[1]) pkg_free(argv[1]);
		return -1;
	}


	if (exp_func_struct->fixup) {
		if (!unsafemodfnc) {
			LM_ERR("Module function '%s' is unsafe. Call is refused.\n", func);
			if (argv[0]) pkg_free(argv[0]);
			if (argv[1]) pkg_free(argv[1]);
			*retval = -1;
			return -1;
		}

		if (argc>=2) {
			*retval = exp_func_struct->fixup(&(act->val[3].u.data), 2);
			if (*retval < 0) {
				LM_ERR("Error in fixup (2)\n");
				return -1;
			}
			act->val[3].type = MODFIXUP_ST;
		}
		if (argc>=1) {
			*retval = exp_func_struct->fixup(&(act->val[2].u.data), 1);
			if (*retval < 0) {
				LM_ERR("Error in fixup (1)\n");
				return -1;
			}
			act->val[2].type = MODFIXUP_ST;
		}
		if (argc==0) {
			*retval = exp_func_struct->fixup(0, 0);
			if (*retval < 0) {
				LM_ERR("Error in fixup (0)\n");
				return -1;
			}
		}
	}

	init_run_actions_ctx(&ra_ctx);
	*retval = do_action(&ra_ctx, act, m);

	if ((act->val[3].type == MODFIXUP_ST) && (act->val[3].u.data)) {
		/* pkg_free(act->elem[3].u.data); */
		LM_WARN("moduleFunction: A fixup function was called. "
				"This currently creates a memory leak.\n");
	}

	if ((act->val[2].type == MODFIXUP_ST) && (act->val[2].u.data)) {
		/* pkg_free(act->elem[2].u.data); */
		LM_WARN("moduleFunction: A fixup function was called. "
				"This currently creates a memory leak.\n");
	}

	if (argv[0]) pkg_free(argv[0]);
	if (argv[1]) pkg_free(argv[1]);

	pkg_free(act);
	
	return 1;
}


/**
 * Rewrite Request-URI
 */
static inline int rewrite_ruri(struct sip_msg* _m, char* _s)
{
	struct action act;
	struct run_act_ctx ra_ctx;

	act.type = SET_URI_T;
	act.val[0].type = STRING_ST;
	act.val[0].u.string = _s;
	act.next = 0;

	init_run_actions_ctx(&ra_ctx);	
	if (do_action(&ra_ctx, &act, _m) < 0)
	{
		LM_ERR("rewrite_ruri: Error in do_action\n");
		return -1;
	}
	return 0;
}


/**
 * Compile a string with pseudo variables substituted by their values.
 * A string buffer is allocated. Deallocate afterwards!
 */
char *pv_sprintf(struct sip_msg *m, char *fmt) {
	int buf_size = 4096;
	char out[4096];
	pv_elem_t *model;
	str s;
	char *ret = NULL;


	s.s = fmt; s.len = strlen(s.s);
	if(pv_parse_format(&s, &model) < 0) {
		LM_ERR("pv_sprintf: ERROR: wrong format[%s]!\n",
			fmt);
		return NULL;
	}

	if(pv_printf(m, model, out, &buf_size) < 0) {
		ret = NULL;
	} else {
		ret = strdup(out);
	}

	pv_elem_free_all(model);

	return ret;
}

/**
 * Convert an SV to an int_str struct. Needed in AVP package.
 * - val: SV to convert.
 * - is: pointer to resulting int_str
 * - flags: pointer to flags to set
 * - strflag: flag mask to be or-applied for string match
 */

inline int sv2int_str(SV *val, int_str *is,
		      unsigned short *flags, unsigned short strflag) {
	char *s;
	STRLEN len;

	if (!SvOK(val)) {
		LM_ERR("AVP:sv2int_str: Invalid value "
			"(not a scalar).\n");
		return 0;
	}
	
	if (SvIOK(val)) { /* numerical name */
		is->n = SvIV(val);
		return 1;
	} else if (SvPOK(val)) {
		s = SvPV(val, len);
		is->s.len = len;
		is->s.s = s;
		(*flags) |= strflag;
		return 1;
	} else {
		LM_ERR("AVP:sv2int_str: Invalid value "
			"(neither string nor integer).\n");
		return 0;
	}
}

/* ************************************************************************ */
/* Object methods begin here */

#if 0
  "Skipped embedded POD."
#endif
#line 434 "kamailioxs.xs"

#line 442 "kamailioxs.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 584 "kamailioxs.c"

XS_EUPXS(XS_Kamailio_log); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio_log)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "level, log");
    {
	int	level = (int)SvIV(ST(0))
;
	char *	log = (char *)SvPV_nolen(ST(1))
;
#line 464 "kamailioxs.xs"
#line 598 "kamailioxs.c"
#line 465 "kamailioxs.xs"
#line 600 "kamailioxs.c"
#line 466 "kamailioxs.xs"
	switch (level) {
	case L_ALERT:	LM_ALERT("%s", log); break;
	case L_CRIT:	LM_CRIT("%s", log); break;
	case L_ERR:	LM_ERR("%s", log); break;
	case L_WARN:	LM_WARN("%s", log); break;
	case L_NOTICE:	LM_NOTICE("%s", log); break;
	case L_INFO:	LM_INFO("%s", log); break;
	default:	LM_DBG("%s", log); break;
	}
#line 611 "kamailioxs.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Kamailio__Message_getType); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_getType)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 502 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
#line 628 "kamailioxs.c"
	int	RETVAL;
	dXSTARG;
#line 504 "kamailioxs.xs"
#line 632 "kamailioxs.c"
#line 505 "kamailioxs.xs"
  	RETVAL = getType(msg);
#line 635 "kamailioxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_getStatus); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_getStatus)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 522 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
    str *ret;
#line 654 "kamailioxs.c"
	SV *	RETVAL;
#line 525 "kamailioxs.xs"
#line 657 "kamailioxs.c"
#line 526 "kamailioxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		if (getType(msg) != SIP_REPLY) {
			LM_ERR("getStatus: Status not available in"
				" non-reply messages.");
			ST(0) = &PL_sv_undef;
		} else {
			ret = &((msg->first_line).u.reply.status);
			ST(0) = sv_2mortal(newSVpv(ret->s, ret->len));
		}
	}
#line 672 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_getReason); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_getReason)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 552 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
    str *ret;
#line 690 "kamailioxs.c"
	SV *	RETVAL;
#line 555 "kamailioxs.xs"
#line 693 "kamailioxs.c"
#line 556 "kamailioxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		if (getType(msg) != SIP_REPLY) {
			LM_ERR("getReason: Reason not available in"
				" non-reply messages.");
			ST(0) = &PL_sv_undef;
		} else {
			ret = &((msg->first_line).u.reply.reason);
			ST(0) = sv_2mortal(newSVpv(ret->s, ret->len));
		}
	}
#line 708 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_getVersion); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_getVersion)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 581 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
    str *ret;
#line 726 "kamailioxs.c"
	SV *	RETVAL;
#line 584 "kamailioxs.xs"
#line 729 "kamailioxs.c"
#line 585 "kamailioxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		if (getType(msg) == SIP_REQUEST) {
			ret = &((msg->first_line).u.request.version);
		} else { /* SIP_REPLY */
			ret = &((msg->first_line).u.reply.version);
		}
		ST(0) = sv_2mortal(newSVpv(ret->s, ret->len));
	}
#line 742 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_getRURI); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_getRURI)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 615 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
    str *ret;
#line 760 "kamailioxs.c"
	SV *	RETVAL;
#line 618 "kamailioxs.xs"
#line 763 "kamailioxs.c"
#line 619 "kamailioxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		if (getType(msg) != SIP_REQUEST) {
			LM_ERR("Not a request message - "
				"no RURI available.\n");
			ST(0) = &PL_sv_undef;
		} else {
			ret = &((msg->first_line).u.request.uri);
			ST(0) = sv_2mortal(newSVpv(ret->s, ret->len));
		}
	}
#line 778 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_getMethod); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_getMethod)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 648 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
    str *ret;
#line 796 "kamailioxs.c"
	char *	RETVAL;
	dXSTARG;
#line 651 "kamailioxs.xs"
#line 800 "kamailioxs.c"
#line 652 "kamailioxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		if (getType(msg) != SIP_REQUEST) {
			LM_ERR("Not a request message - "
				"no method available.\n");
			ST(0) = &PL_sv_undef;
		} else {
			ret = &((msg->first_line).u.request.method);
			ST(0) = sv_2mortal(newSVpv(ret->s, ret->len));
		}
	}
#line 815 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_getFullHeader); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_getFullHeader)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 681 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
    char *firsttoken;
    long headerlen;
#line 834 "kamailioxs.c"
	SV *	RETVAL;
#line 685 "kamailioxs.xs"
#line 837 "kamailioxs.c"
#line 686 "kamailioxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		if (getType(msg) == SIP_INVALID) {
			LM_ERR("getFullHeader: Invalid message type.\n");
			ST(0)  = &PL_sv_undef;
		} else {
			parse_headers(msg, ~0, 0);
			if (getType(msg) == SIP_REQUEST) {
				firsttoken = (msg->first_line).u.request.method.s;
			} else { /* SIP_REPLY */
				firsttoken = (msg->first_line).u.reply.version.s;
			}

			if (msg->eoh == NULL)
				headerlen = 0;
			else
				headerlen = ((long)(msg->eoh))
						-((long)(firsttoken));

			if (headerlen > 0) {
				ST(0) = 
				    sv_2mortal(newSVpv(firsttoken, headerlen));
			} else {
				ST(0) = &PL_sv_undef;
			}
		}
	}
#line 868 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_getBody); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_getBody)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 727 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
#line 885 "kamailioxs.c"
	SV *	RETVAL;
#line 729 "kamailioxs.xs"
#line 888 "kamailioxs.c"
#line 730 "kamailioxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		parse_headers(msg, ~0, 0);
		ST(0) = sv_2mortal(newSVpv(get_body(msg), 0));
	}
#line 897 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_getMessage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_getMessage)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 749 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
#line 914 "kamailioxs.c"
	SV *	RETVAL;
#line 751 "kamailioxs.xs"
#line 917 "kamailioxs.c"
#line 752 "kamailioxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		ST(0) = sv_2mortal(newSVpv(msg->buf, 0));
	}
#line 925 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_getHeader); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_getHeader)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	self = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
#line 775 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
    str *body = NULL;
    struct hdr_field *hf;
    int found = 0;
    int namelen = strlen(name);
#line 950 "kamailioxs.c"
	SV *	RETVAL;
#line 781 "kamailioxs.xs"
#line 953 "kamailioxs.c"
#line 782 "kamailioxs.xs"
	LM_DBG("searching '%s'\n", name);

	if (!msg) {
		LM_ERR("Invalid message reference\n");
	} else {
		parse_headers(msg, ~0, 0);
		for (hf = msg->headers; hf; hf = hf->next) {
			if (namelen == hf->name.len) {
				if (strncmp(name, hf->name.s, namelen) == 0) {
					/* Found the right header. */
					found = 1;
					body = &(hf->body);
					XPUSHs(sv_2mortal(newSVpv(body->s,
								  body->len)));
				}
			}
		}
	}
	if (!found) {
		XPUSHs(&PL_sv_undef);
	}
#line 976 "kamailioxs.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Kamailio__Message_getHeaderNames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_getHeaderNames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	self = ST(0)
;
#line 816 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
    struct hdr_field *hf = NULL;
    int found = 0;
#line 998 "kamailioxs.c"
	AV *	RETVAL;
#line 821 "kamailioxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
	} else {
		parse_headers(msg, ~0, 0);
		for (hf = msg->headers; hf; hf = hf->next) {
			found = 1;
			XPUSHs(sv_2mortal(newSVpv(hf->name.s, hf->name.len)));
		}
	}
	if (!found) {
		XPUSHs(&PL_sv_undef);
	}
#line 1013 "kamailioxs.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Kamailio__Message_moduleFunction); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_moduleFunction)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "self, func, string1 = NULL, string2 = NULL");
    {
	SV *	self = ST(0)
;
	char *	func = (char *)SvPV_nolen(ST(1))
;
	char *	string1;
	char *	string2;
#line 967 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
    int retval; /* Return value of called function */
    int ret;    /* Return value of moduleFunc - < 0 for "non existing function" and other errors */
#line 1037 "kamailioxs.c"
	int	RETVAL;
	dXSTARG;

	if (items < 3)
	    string1 = NULL;
	else {
	    string1 = (char *)SvPV_nolen(ST(2))
;
	}

	if (items < 4)
	    string2 = NULL;
	else {
	    string2 = (char *)SvPV_nolen(ST(3))
;
	}
#line 971 "kamailioxs.xs"
#line 1055 "kamailioxs.c"
#line 972 "kamailioxs.xs"
	LM_DBG("Calling exported func '%s', Param1 is '%s',"
		" Param2 is '%s'\n", func, string1, string2);

	ret = moduleFunc(msg, func, string1, string2, &retval);
	if (ret < 0) {
		LM_ERR("calling module function '%s' failed."
			" Missing loadmodule?\n", func);
		retval = -1;
	}
	RETVAL = retval;
#line 1067 "kamailioxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_log); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_log)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, level, log");
    {
	SV *	self = ST(0)
;
	int	level = (int)SvIV(ST(1))
;
	char *	log = (char *)SvPV_nolen(ST(2))
;
#line 1011 "kamailioxs.xs"
#line 1088 "kamailioxs.c"
#line 1012 "kamailioxs.xs"
#line 1090 "kamailioxs.c"
#line 1013 "kamailioxs.xs"
	switch (level) {
	case L_ALERT:	LM_ALERT("%s", log); break;
	case L_CRIT:	LM_CRIT("%s", log); break;
	case L_ERR:	LM_ERR("%s", log); break;
	case L_WARN:	LM_WARN("%s", log); break;
	case L_NOTICE:	LM_NOTICE("%s", log); break;
	case L_INFO:	LM_INFO("%s", log); break;
	default:	LM_DBG("%s", log); break;
	}
#line 1101 "kamailioxs.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Kamailio__Message_rewrite_ruri); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_rewrite_ruri)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, newruri");
    {
	SV *	self = ST(0)
;
	char *	newruri = (char *)SvPV_nolen(ST(1))
;
#line 1041 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
#line 1120 "kamailioxs.c"
	int	RETVAL;
	dXSTARG;
#line 1043 "kamailioxs.xs"
#line 1124 "kamailioxs.c"
#line 1044 "kamailioxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		RETVAL = -1;
	} else {
		if (getType(msg) != SIP_REQUEST) {
			LM_ERR("Not a Request. RURI rewrite unavailable.\n");
			RETVAL = -1;
		} else {
			LM_DBG("New R-URI is [%s]\n", newruri);
			RETVAL = rewrite_ruri(msg, newruri);
		}
	}
#line 1138 "kamailioxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_setFlag); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_setFlag)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, flag");
    {
	SV *	self = ST(0)
;
	unsigned int	flag = (unsigned int)SvUV(ST(1))
;
#line 1073 "kamailioxs.xs"
	struct sip_msg *msg = sv2msg(self);
#line 1158 "kamailioxs.c"
	int	RETVAL;
	dXSTARG;
#line 1075 "kamailioxs.xs"
#line 1162 "kamailioxs.c"
#line 1076 "kamailioxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		RETVAL = -1;
	} else {
		RETVAL = setflag(msg, flag);
	}
#line 1170 "kamailioxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_resetFlag); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_resetFlag)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, flag");
    {
	SV *	self = ST(0)
;
	unsigned int	flag = (unsigned int)SvUV(ST(1))
;
#line 1097 "kamailioxs.xs"
	struct sip_msg *msg = sv2msg(self);
#line 1190 "kamailioxs.c"
	int	RETVAL;
	dXSTARG;
#line 1099 "kamailioxs.xs"
#line 1194 "kamailioxs.c"
#line 1100 "kamailioxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		RETVAL = -1;
	} else {
		RETVAL = resetflag(msg, flag);
	}
#line 1202 "kamailioxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_isFlagSet); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_isFlagSet)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, flag");
    {
	SV *	self = ST(0)
;
	unsigned int	flag = (unsigned int)SvUV(ST(1))
;
#line 1120 "kamailioxs.xs"
	struct sip_msg *msg = sv2msg(self);
#line 1222 "kamailioxs.c"
	int	RETVAL;
	dXSTARG;
#line 1122 "kamailioxs.xs"
#line 1226 "kamailioxs.c"
#line 1123 "kamailioxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		RETVAL = -1;
	} else {
		RETVAL = isflagset(msg, flag) == 1 ? 1 : 0;
	}
#line 1234 "kamailioxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_pseudoVar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_pseudoVar)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, varstring");
    {
	SV *	self = ST(0)
;
	char *	varstring = (char *)SvPV_nolen(ST(1))
;
#line 1147 "kamailioxs.xs"
	struct sip_msg *msg = sv2msg(self);
	char *ret;
#line 1255 "kamailioxs.c"
	SV *	RETVAL;
#line 1150 "kamailioxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		ret = pv_sprintf(msg, varstring);
		if (ret) {
			ST(0) = sv_2mortal(newSVpv(ret, strlen(ret)));
			free(ret);
		} else {
			ST(0) = &PL_sv_undef;
		}
	}
#line 1270 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_append_branch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_append_branch)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "self, branch = NULL, qval = NULL");
    {
	SV *	self = ST(0)
;
	char *	branch;
	char *	qval;
#line 1177 "kamailioxs.xs"
	struct sip_msg *msg = sv2msg(self);
	qvalue_t q = Q_UNSPECIFIED;
	str b = {0, 0};
#line 1291 "kamailioxs.c"
	int	RETVAL;
	dXSTARG;

	if (items < 2)
	    branch = NULL;
	else {
	    branch = (char *)SvPV_nolen(ST(1))
;
	}

	if (items < 3)
	    qval = NULL;
	else {
	    qval = (char *)SvPV_nolen(ST(2))
;
	}
#line 1181 "kamailioxs.xs"
#line 1309 "kamailioxs.c"
#line 1182 "kamailioxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		RETVAL = -1;
	} else {
		if (qval) {
			if (str2q(&q, qval, strlen(qval)) < 0) {
				LM_ERR("append_branch: Bad q value.");
			} else { /* branch and qval set */
				b.s = branch;
				b.len = strlen(branch);
			}
		} else {
			if (branch) { /* branch set, qval unset */
				b.s = branch;
				b.len = strlen(branch);
			}
		}

		RETVAL = km_append_branch(msg, (b.s!=0)?&b:0, 0, 0, q, 0, 0);
	}
#line 1331 "kamailioxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__Message_getParsedRURI); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__Message_getParsedRURI)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
#line 1217 "kamailioxs.xs"
    struct sip_msg *msg = sv2msg(self);
    struct sip_uri *uri;
    SV *ret;
#line 1351 "kamailioxs.c"
	SV *	RETVAL;
#line 1221 "kamailioxs.xs"
#line 1354 "kamailioxs.c"
#line 1222 "kamailioxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = NULL;
	} else {
		parse_sip_msg_uri(msg);
		parse_headers(msg, ~0, 0);

		uri = &(msg->parsed_uri);
		ret = sv_newmortal();
		sv_setref_pv(ret, "Kamailio::URI", (void *)uri);
		SvREADONLY_on(SvRV(ret));

		ST(0) = ret;
	}
#line 1370 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_user); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_user)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1260 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_USER);
#line 1388 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_host); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_host)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1273 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_HOST);
#line 1406 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_passwd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_passwd)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1286 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_PASSWD);
#line 1424 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_port); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_port)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1299 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_PORT);
#line 1442 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_params); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_params)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1312 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_PARAMS);
#line 1460 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_headers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_headers)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1325 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_HEADERS);
#line 1478 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_transport); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_transport)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1338 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_TRANSPORT);
#line 1496 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_ttl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_ttl)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1351 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_TTL);
#line 1514 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_user_param); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_user_param)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1364 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_USER_PARAM);
#line 1532 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_maddr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_maddr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1378 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_MADDR);
#line 1550 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_method); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_method)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1390 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_METHOD);
#line 1568 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_lr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_lr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1403 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_LR);
#line 1586 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_r2); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_r2)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1416 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_R2);
#line 1604 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_transport_val); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_transport_val)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1429 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_TRANSPORT_VAL);
#line 1622 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_ttl_val); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_ttl_val)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1442 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_TTL_VAL);
#line 1640 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_user_param_val); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_user_param_val)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1455 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_USER_PARAM_VAL);
#line 1658 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_maddr_val); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_maddr_val)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1468 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_MADDR_VAL);
#line 1676 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_method_val); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_method_val)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1481 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_METHOD_VAL);
#line 1694 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_lr_val); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_lr_val)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1494 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_LR_VAL);
#line 1712 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__URI_r2_val); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__URI_r2_val)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	SV *	RETVAL;
#line 1507 "kamailioxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_R2_VAL);
#line 1730 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__AVP_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__AVP_add)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "p_name, p_val");
    {
	SV *	p_name = ST(0)
;
	SV *	p_val = ST(1)
;
#line 1551 "kamailioxs.xs"
	int_str name;
	int_str val;
	unsigned short flags = 0;
	char *s;
	STRLEN len;
#line 1753 "kamailioxs.c"
	int	RETVAL;
	dXSTARG;
#line 1557 "kamailioxs.xs"
  	RETVAL = 0;
	if (SvOK(p_name) && SvOK(p_val)) {
		if (!sv2int_str(p_name, &name, &flags, AVP_NAME_STR)) {
			RETVAL = -1;
		} else if (!sv2int_str(p_val, &val, &flags, AVP_VAL_STR)) {
			RETVAL = -1;
		}

		if (RETVAL == 0) {
			RETVAL = add_avp(flags, name, val);
		}
	}
#line 1769 "kamailioxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__AVP_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__AVP_get)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p_name");
    {
	SV *	p_name = ST(0)
;
#line 1588 "kamailioxs.xs"
	struct usr_avp *first_avp;
	int_str name;
	int_str val;
	unsigned short flags = 0;
	SV *ret = &PL_sv_undef;
	int err = 0;
	char *s;
	STRLEN len;
#line 1794 "kamailioxs.c"
	int	RETVAL;
	dXSTARG;
#line 1597 "kamailioxs.xs"
	if (SvOK(p_name)) {
		if (!sv2int_str(p_name, &name, &flags, AVP_NAME_STR)) {
			LM_ERR("AVP:get: Invalid name.");
			err = 1;
		}
	} else {
		LM_ERR("AVP:get: Invalid name.");
		err = 1;
	}

	if (err == 0) {
		first_avp = search_first_avp(flags, name, &val, NULL);

		if (first_avp != NULL) { /* found correct AVP */
			if (is_avp_str_val(first_avp)) {
				ret = sv_2mortal(newSVpv(val.s.s, val.s.len));
			} else {
				ret = sv_2mortal(newSViv(val.n));
			}
		} else {
			/* Empty AVP requested. */
		}
	}

	ST(0) = ret;
#line 1823 "kamailioxs.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Kamailio__AVP_destroy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Kamailio__AVP_destroy)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p_name");
    {
	SV *	p_name = ST(0)
;
#line 1639 "kamailioxs.xs"
	struct usr_avp *first_avp;
	int_str name;
	int_str val;
	unsigned short flags = 0;
	SV *ret = &PL_sv_undef;
	char *s;
	STRLEN len;
#line 1846 "kamailioxs.c"
	int	RETVAL;
	dXSTARG;
#line 1647 "kamailioxs.xs"
	RETVAL = 1;
	if (SvOK(p_name)) {
		if (!sv2int_str(p_name, &name, &flags, AVP_NAME_STR)) {
			RETVAL = 0;
			LM_ERR("AVP:destroy: Invalid name.");
		}
	} else {
		RETVAL = 0;
		LM_ERR("VP:destroy: Invalid name.");
	}

	if (RETVAL == 1) {
		first_avp = search_first_avp(flags, name, &val, NULL);

		if (first_avp != NULL) { /* found correct AVP */
			destroy_avp(first_avp);
		} else {
			RETVAL = 0;
			/* Empty AVP requested. */
		}
	}

#line 1872 "kamailioxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Kamailio); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Kamailio)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("Kamailio::log", XS_Kamailio_log, file);
        (void)newXSproto_portable("Kamailio::Message::getType", XS_Kamailio__Message_getType, file, "$");
        (void)newXSproto_portable("Kamailio::Message::getStatus", XS_Kamailio__Message_getStatus, file, "$");
        (void)newXSproto_portable("Kamailio::Message::getReason", XS_Kamailio__Message_getReason, file, "$");
        (void)newXSproto_portable("Kamailio::Message::getVersion", XS_Kamailio__Message_getVersion, file, "$");
        (void)newXSproto_portable("Kamailio::Message::getRURI", XS_Kamailio__Message_getRURI, file, "$");
        (void)newXSproto_portable("Kamailio::Message::getMethod", XS_Kamailio__Message_getMethod, file, "$");
        (void)newXSproto_portable("Kamailio::Message::getFullHeader", XS_Kamailio__Message_getFullHeader, file, "$");
        (void)newXSproto_portable("Kamailio::Message::getBody", XS_Kamailio__Message_getBody, file, "$");
        (void)newXSproto_portable("Kamailio::Message::getMessage", XS_Kamailio__Message_getMessage, file, "$");
        (void)newXSproto_portable("Kamailio::Message::getHeader", XS_Kamailio__Message_getHeader, file, "$$");
        (void)newXSproto_portable("Kamailio::Message::getHeaderNames", XS_Kamailio__Message_getHeaderNames, file, "$");
        (void)newXSproto_portable("Kamailio::Message::moduleFunction", XS_Kamailio__Message_moduleFunction, file, "$$;$$");
        (void)newXSproto_portable("Kamailio::Message::log", XS_Kamailio__Message_log, file, "$$$");
        (void)newXSproto_portable("Kamailio::Message::rewrite_ruri", XS_Kamailio__Message_rewrite_ruri, file, "$$");
        (void)newXSproto_portable("Kamailio::Message::setFlag", XS_Kamailio__Message_setFlag, file, "$$");
        (void)newXSproto_portable("Kamailio::Message::resetFlag", XS_Kamailio__Message_resetFlag, file, "$$");
        (void)newXSproto_portable("Kamailio::Message::isFlagSet", XS_Kamailio__Message_isFlagSet, file, "$$");
        (void)newXSproto_portable("Kamailio::Message::pseudoVar", XS_Kamailio__Message_pseudoVar, file, "$$");
        (void)newXSproto_portable("Kamailio::Message::append_branch", XS_Kamailio__Message_append_branch, file, "$;$$");
        (void)newXSproto_portable("Kamailio::Message::getParsedRURI", XS_Kamailio__Message_getParsedRURI, file, "$");
        (void)newXSproto_portable("Kamailio::URI::user", XS_Kamailio__URI_user, file, "$");
        (void)newXSproto_portable("Kamailio::URI::host", XS_Kamailio__URI_host, file, "$");
        (void)newXSproto_portable("Kamailio::URI::passwd", XS_Kamailio__URI_passwd, file, "$");
        (void)newXSproto_portable("Kamailio::URI::port", XS_Kamailio__URI_port, file, "$");
        (void)newXSproto_portable("Kamailio::URI::params", XS_Kamailio__URI_params, file, "$");
        (void)newXSproto_portable("Kamailio::URI::headers", XS_Kamailio__URI_headers, file, "$");
        (void)newXSproto_portable("Kamailio::URI::transport", XS_Kamailio__URI_transport, file, "$");
        (void)newXSproto_portable("Kamailio::URI::ttl", XS_Kamailio__URI_ttl, file, "$");
        (void)newXSproto_portable("Kamailio::URI::user_param", XS_Kamailio__URI_user_param, file, "$");
        (void)newXSproto_portable("Kamailio::URI::maddr", XS_Kamailio__URI_maddr, file, "$");
        (void)newXSproto_portable("Kamailio::URI::method", XS_Kamailio__URI_method, file, "$");
        (void)newXSproto_portable("Kamailio::URI::lr", XS_Kamailio__URI_lr, file, "$");
        (void)newXSproto_portable("Kamailio::URI::r2", XS_Kamailio__URI_r2, file, "$");
        (void)newXSproto_portable("Kamailio::URI::transport_val", XS_Kamailio__URI_transport_val, file, "$");
        (void)newXSproto_portable("Kamailio::URI::ttl_val", XS_Kamailio__URI_ttl_val, file, "$");
        (void)newXSproto_portable("Kamailio::URI::user_param_val", XS_Kamailio__URI_user_param_val, file, "$");
        (void)newXSproto_portable("Kamailio::URI::maddr_val", XS_Kamailio__URI_maddr_val, file, "$");
        (void)newXSproto_portable("Kamailio::URI::method_val", XS_Kamailio__URI_method_val, file, "$");
        (void)newXSproto_portable("Kamailio::URI::lr_val", XS_Kamailio__URI_lr_val, file, "$");
        (void)newXSproto_portable("Kamailio::URI::r2_val", XS_Kamailio__URI_r2_val, file, "$");
        (void)newXSproto_portable("Kamailio::AVP::add", XS_Kamailio__AVP_add, file, "$$");
        (void)newXSproto_portable("Kamailio::AVP::get", XS_Kamailio__AVP_get, file, "$");
        (void)newXSproto_portable("Kamailio::AVP::destroy", XS_Kamailio__AVP_destroy, file, "$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

